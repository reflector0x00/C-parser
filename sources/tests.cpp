#include <fstream>
#define CATCH_CONFIG_MAIN
#include "catch.hpp"
#include "c_parser.h"


SCENARIO("parse \"Hello, world!\" program", "[c_parser]" ) {
	std::ifstream file_in("hello_world.c");
	REQUIRE(file_in.is_open());
	c_parser parser(file_in);
	REQUIRE_NOTHROW(parser.run());
	
	SECTION("output of program - tree structure") {
		REQUIRE_NOTHROW(parser.get_tree());
	}

	parse_tree<c_token>& tree_res = parser.get_tree();
	std::ifstream file_gv("hello_world.gv");
	REQUIRE(file_gv.is_open());
	parse_tree<c_token> tree_check;
	SECTION("you can read graphviz files, generated by this program and compare them as trees") {
		REQUIRE_NOTHROW(tree_check = parse_tree<c_token>(file_gv));
		REQUIRE(tree_res == tree_check);
	}
}

SCENARIO("typedefs and unions also processed", "[c_parser]") {
	SECTION("typedefs and uinions as type") {
		{
			std::ifstream file_in("typedef_union.c");
			REQUIRE(file_in.is_open());
			c_parser parser(file_in);
			REQUIRE_NOTHROW(parser.run());
			
			parse_tree<c_token>& tree_res = parser.get_tree();
			std::ifstream file_gv("typedef_union.gv");
			REQUIRE(file_gv.is_open());
			parse_tree<c_token> tree_check;
			REQUIRE_NOTHROW(tree_check = parse_tree<c_token>(file_gv));
			REQUIRE(tree_res == tree_check);
		}
	}
	
	SECTION("non-type identifier as type") {
		{
			std::ifstream file_in("bad_type.c");
			REQUIRE(file_in.is_open());
			c_parser parser(file_in);
			REQUIRE_THROWS_AS(parser.run(), std::runtime_error);
		}
	}
}

SCENARIO("shift-reduce conflicts are solved by the shift preference, rather than the convolution", "[c_parser]") {
	std::ifstream file_in("shift-reduce.c");
	REQUIRE(file_in.is_open());
	c_parser parser(file_in);
	REQUIRE_NOTHROW(parser.run());

	parse_tree<c_token>& tree_res = parser.get_tree();
	std::ifstream file_gv("shift-reduce.gv");
	REQUIRE(file_gv.is_open());
	parse_tree<c_token> tree_check;
	REQUIRE_NOTHROW(tree_check = parse_tree<c_token>(file_gv));
	REQUIRE(tree_res == tree_check);
}


SCENARIO("empty file isn't program", "[c_parser]") {
	std::ifstream file_in("empty.c");
	REQUIRE(file_in.is_open());
	c_parser parser(file_in);
	REQUIRE_THROWS_AS(parser.run(), std::runtime_error);
}
